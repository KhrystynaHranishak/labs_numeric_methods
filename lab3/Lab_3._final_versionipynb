{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Метод Якобі"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from math import sqrt\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# дані для тестування\n",
    "def test_1():\n",
    "    matrix = [[1., 1., 3.], [1., 5., 1.], [3., 1., 1.]]\n",
    "    return np.array(matrix)\n",
    "\n",
    "def test_2():\n",
    "    matrix = [[1.6, 0.7, 0.8], [0.7, 1.6, 0.3], [0.8, 0.3, 1.6]]\n",
    "    return np.array(matrix)\n",
    "\n",
    "def test_3():\n",
    "    matrix = [[5., 1., -3.], [3., 0., -2.], [-4., -1., 1.]]\n",
    "    return np.array(matrix)\n",
    "\n",
    "def test_4():\n",
    "    matrix = [[1., 0., 0., 0.], [0., 0., 0., 0.], [1., 0., 0., 0.], [0., 0., 0., 1.]]\n",
    "    return np.array(matrix)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# допоміжні функції\n",
    "def find_max_element(matrix):\n",
    "    max_el = 0.\n",
    "    max_indx = (0, 0)\n",
    "    for index, el in np.ndenumerate(matrix):\n",
    "        if ((index[0] != index[1])):\n",
    "            if (max_el < abs(el)):\n",
    "                max_el = abs(el)\n",
    "                max_indx = index\n",
    "    return max_el, max_indx\n",
    "\n",
    "def create_matrix_T(matrix, index): # index is tuple (i, j)\n",
    "    matrix_T = np.zeros_like(matrix, dtype=float)\n",
    "    np.fill_diagonal(matrix_T, 1)\n",
    "    p = 2 * matrix[index]\n",
    "    q = matrix[index[1]][index[1]] - matrix[index[0]][index[0]]\n",
    "    #print(q)\n",
    "    if (q == 0):\n",
    "        c = sqrt(2) / 2\n",
    "        s = sqrt(2) / 2\n",
    "    else:\n",
    "        d = sqrt(p ** 2 + q ** 2)\n",
    "        r = abs(q) / (2 * d)\n",
    "        c = sqrt(0.5 + r)\n",
    "        if (p * q >= 0):\n",
    "            s = sqrt(0.5 - r)\n",
    "        else:\n",
    "            s = -sqrt(0.5 - r)\n",
    "    matrix_T[index[0]][index[0]] = c\n",
    "    matrix_T[index[1]][index[1]] = c\n",
    "    matrix_T[index[0]][index[1]] = s\n",
    "    matrix_T[index[1]][index[0]] = -s\n",
    "\n",
    "    return matrix_T\n",
    "\n",
    "def create_matrix_B(matrix, matrix_T, index):\n",
    "    i = index[0]\n",
    "    j = index[1]\n",
    "    matrix_B = matrix.copy()\n",
    "    # new diagonal elements\n",
    "    matrix_B[i][i] = (matrix_T[i][i] ** 2) * matrix[i][i] + (matrix_T[i][j] ** 2) * matrix[j][j] - 2 * matrix_T[i][i] * matrix_T[i][j] * matrix[i][j]\n",
    "    matrix_B[j][j] = (matrix_T[i][j] ** 2) * matrix[i][i] + (matrix_T[i][i] ** 2) * matrix[j][j] + 2 * matrix_T[i][i] * matrix_T[i][j] * matrix[i][j]\n",
    "    # other elements of B\n",
    "    matrix_B[i][j] = 0.\n",
    "    matrix_B[j][i] = 0.\n",
    "\n",
    "    for m in range(matrix.shape[0]):\n",
    "        if ((m != i) & (m != j)):\n",
    "            matrix_B[i][m] = matrix_T[i][i] * matrix[m][i] - matrix_T[i][j] * matrix[m][j]\n",
    "            matrix_B[m][i] = matrix_T[i][i] * matrix[m][i] - matrix_T[i][j] * matrix[m][j]\n",
    "            matrix_B[j][m] = matrix_T[i][j] * matrix[m][i] + matrix_T[i][i] * matrix[m][j]\n",
    "            matrix_B[m][j] = matrix_T[i][j] * matrix[m][i] + matrix_T[i][i] * matrix[m][j]\n",
    "    return matrix_B\n",
    "\n",
    "def check_stop_condition(matrix_B, eps):\n",
    "    for index, el in np.ndenumerate(matrix_B):\n",
    "        if (index[0] != index[1]):\n",
    "            if (abs(el) > eps):\n",
    "                return False\n",
    "    return True\n",
    "\n",
    "def get_trace_matrix(matrix):\n",
    "    trace = 0\n",
    "    for index, el in np.ndenumerate(matrix):\n",
    "        if (index[0] == index[1]):\n",
    "            trace += el\n",
    "    return trace"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Jaccobi_method(matrix, eps):\n",
    "    list_Ti = []\n",
    "    sequence_max = []\n",
    "    sequence_traces = []\n",
    "    k = 0\n",
    "    while True:\n",
    "        #print(matrix)\n",
    "        max_el, index = find_max_element(matrix)\n",
    "        #print(max_el, index)\n",
    "        sequence_max.append(max_el)\n",
    "        matrix_T = create_matrix_T(matrix, index)\n",
    "        #print(matrix_T)\n",
    "        matrix_B = create_matrix_B(matrix, matrix_T, index)\n",
    "        trace = get_trace_matrix(matrix_B)\n",
    "        sequence_traces.append(trace)\n",
    "        #print(matrix_B)\n",
    "        if not (check_stop_condition(matrix_B, eps)):\n",
    "            matrix = matrix_B.copy()\n",
    "            list_Ti.append(matrix_T)\n",
    "        else:\n",
    "            list_Ti.append(matrix_T)\n",
    "            break\n",
    "    return matrix_B, list_Ti, sequence_max, sequence_traces\n",
    "\n",
    "def find_vectors(list_Ti):\n",
    "    product = np.zeros_like(list_Ti[0], dtype=float)\n",
    "    np.fill_diagonal(product, 1)\n",
    "    for matrix in list_Ti:\n",
    "        product = product.dot(matrix)\n",
    "    return product\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# виведення для методу Якобі\n",
    "EPS = sys.float_info.epsilon\n",
    "\n",
    "A_1 = test_1()\n",
    "val_matrix_1, T_list_1, seq_max_1, seq_trace_1 = Jaccobi_method(A_1.copy(), EPS)\n",
    "Q_1 = find_vectors(T_list_1)\n",
    "\n",
    "print('Initial matrix \\n {}'.format(A_1))\n",
    "print('A matrix with values on a diagonal \\n {}'.format(val_matrix_1))\n",
    "print('A matrix with vectors \\n {}'.format(Q_1))\n",
    "\n",
    "print('Check')\n",
    "Q_1T = np.transpose(Q_1)\n",
    "print(Q_1T.dot(Q_1))\n",
    "print('\\n')\n",
    "x = np.matmul(Q_1, val_matrix_1)\n",
    "print(x.dot(Q_1T) - A_1)\n",
    "\n",
    "print('Sequence of max element\\'s of absolute values \\n {}'.format(seq_max_1))\n",
    "print('Sequence of the matrix\\' traces \\n {}'.format(seq_trace_1))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### QR розклад"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# допоміжні функції\n",
    "def sign_plus(x):\n",
    "    if x >= 0:\n",
    "        return 1\n",
    "    return -1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Обчислення матриці Хаусхолдера\n",
    "def create_H(matrix, i, j):\n",
    "    E = np.zeros_like(matrix, dtype=float)\n",
    "    np.fill_diagonal(E, 1)\n",
    "    summ = 0\n",
    "    for k in range(i, matrix.shape[1]):\n",
    "        summ += matrix[k][j] ** 2\n",
    "    beta = sign_plus((-1)* matrix[i][j]) * sqrt(summ)\n",
    "    if ((2 * (beta ** 2) - 2 * matrix[i][j] * beta) == 0):\n",
    "        return E # тобто пропускаємо крок, оскільки вже є потрібні нулі в матриці\n",
    "    else:\n",
    "        mu = 1 / sqrt(2 * (beta ** 2) - 2 * matrix[i][j] * beta)\n",
    "    vector_w = np.zeros(matrix.shape[1])\n",
    "    for k in range(matrix.shape[1]):\n",
    "        if (k < i):\n",
    "            vector_w[k] = 0\n",
    "        elif (k == i):\n",
    "            vector_w[k] = mu * (matrix[i][j] - beta)\n",
    "        else:\n",
    "            vector_w[k] = mu * matrix[k][j]\n",
    "    vector_w_T = vector_w.reshape(1, vector_w.size)\n",
    "    vector_w = vector_w.reshape(vector_w.size, 1)\n",
    "    H = E - 2 * vector_w.dot(vector_w_T)\n",
    "    return H"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Матриця Хесенберга\n",
    "def create_Hesenberg_matrix(matrix):\n",
    "    list_Hi = []\n",
    "    for j in range(matrix.shape[1] - 2):\n",
    "        for i in range(j+1, matrix.shape[0]):\n",
    "            if ((i - j) == 1):\n",
    "                H = create_H(matrix, i, j)\n",
    "                list_Hi.append(H)\n",
    "                matrix = H.dot(matrix)\n",
    "    return matrix, list_Hi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Створення подібної до початкової\n",
    "def create_similar_B0(Hesenberg_matrix, list_Hi):\n",
    "    product_H = np.zeros_like(list_Hi[0], dtype=float)\n",
    "    np.fill_diagonal(product_H, 1)\n",
    "    for matrix in list_Hi:\n",
    "        product_H = product_H.dot(matrix)\n",
    "    return Hesenberg_matrix.dot(product_H)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# створення матриці Гівенса\n",
    "def create_G(matrix, i, j, eps=0.000001):  # матриця повороту для QR розкладу\n",
    "    G = np.zeros_like(matrix, dtype ='float')\n",
    "    np.fill_diagonal(G, 1)\n",
    "    if (abs(matrix[i-1][j]) > eps):\n",
    "        t = matrix[i][j] / matrix[i-1][j]\n",
    "        c = 1 / sqrt(1 + t ** 2)\n",
    "        s = t / sqrt(1 + t ** 2)\n",
    "    else:\n",
    "        s = 0\n",
    "        c = 1\n",
    "    G[i-1][j] = c\n",
    "    G[i][j + 1] = c\n",
    "    G[i][j] = -s\n",
    "    G[i - 1][j + 1] = s\n",
    "    return G"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# QR-розклад\n",
    "def check_stop_condition_Hivens(matrix_B, eps):\n",
    "    for index, el in np.ndenumerate(matrix_B):\n",
    "        if ((index[0] - index[1]) == 1):\n",
    "            if (abs(el) > eps):\n",
    "                return False\n",
    "    return True\n",
    "\n",
    "def create_under_diagonal(B0):\n",
    "    list_Gi = []\n",
    "    R = B0.copy()\n",
    "    for j in range(B0.shape[1] - 1):\n",
    "        i = j + 1\n",
    "        G = create_G(R, i,j)\n",
    "        R = G.dot(R)\n",
    "        list_Gi.append(G)\n",
    "    return R, list_Gi\n",
    "\n",
    "def create_Q(list_Gi):\n",
    "    Q = np.zeros_like(list_Gi[0], dtype ='float')\n",
    "    np.fill_diagonal(Q, 1)\n",
    "    for G in list_Gi:\n",
    "        G_T = np.transpose(G)\n",
    "        Q = Q.dot(G_T)\n",
    "    return Q\n",
    "\n",
    "def create_new_B(R, Q, eps):\n",
    "    B_new = R.dot(Q)\n",
    "    while (check_stop_condition_Hivens(B_new, eps) != True):\n",
    "        R, list_Gi = create_under_diagonal(B_new)\n",
    "        Q = create_Q(list_Gi)\n",
    "        B_new = R.dot(Q)\n",
    "    return B_new"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The initial matrix \n",
      " [[1. 0. 0. 0.]\n",
      " [0. 0. 0. 0.]\n",
      " [1. 0. 0. 0.]\n",
      " [0. 0. 0. 1.]]\n",
      "\n",
      "\n",
      "The similar matrix to A in Hessenberg's form \n",
      " [[1.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00]\n",
      " [1.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00]\n",
      " [2.22044605e-16 0.00000000e+00 0.00000000e+00 0.00000000e+00]\n",
      " [0.00000000e+00 0.00000000e+00 0.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "\n",
      "A matrix with eigenvalues on a diagonal \n",
      " [[ 1.00000000e+00 -1.00000000e+00  0.00000000e+00  0.00000000e+00]\n",
      " [-3.25176795e-17  3.25176795e-17  0.00000000e+00  0.00000000e+00]\n",
      " [ 1.57009246e-16 -1.57009246e-16  0.00000000e+00  0.00000000e+00]\n",
      " [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n",
      "\n",
      "\n",
      "The QR factorization of the initial matrix\n",
      "R: [[ 1.41421356e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n",
      " [-4.59869434e-17  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n",
      " [ 2.22044605e-16  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n",
      " [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n",
      "Q: [[ 0.70710678 -0.70710678  0.          0.        ]\n",
      " [ 0.70710678  0.70710678  0.          0.        ]\n",
      " [ 0.          0.          1.          0.        ]\n",
      " [ 0.          0.          0.          1.        ]]\n",
      "The QR factorization of the initial matrix with library\n",
      "R: [[-1.41421356  0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.        ]\n",
      " [ 0.          0.          0.          0.        ]\n",
      " [ 0.          0.          0.          1.        ]]\n",
      "Q: [[-7.07106781e-01 -7.07106781e-01 -1.57009246e-16  0.00000000e+00]\n",
      " [-7.07106781e-01  7.07106781e-01 -6.50353591e-17  0.00000000e+00]\n",
      " [-1.57009246e-16 -6.50353591e-17  1.00000000e+00  0.00000000e+00]\n",
      " [-0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n"
     ]
    }
   ],
   "source": [
    "# виведення для QR-розкладу\n",
    "EPS_QR = 0.0001 # точність, з якою зведеться матриця А до трикутної з власними числами на діагоналі\n",
    "A_2 = test_4()\n",
    "Hessenberg_matrix, l_H = create_Hesenberg_matrix(A_2.copy())\n",
    "sim_B = create_similar_B0(Hessenberg_matrix, l_H)\n",
    "R, l_G = create_under_diagonal(sim_B.copy())\n",
    "Q = create_Q(l_G)\n",
    "finall_B = create_new_B(R, Q, EPS_QR)\n",
    "\n",
    "print('The initial matrix \\n {}'.format(A_2))\n",
    "print('\\n')\n",
    "print('The similar matrix to A in Hessenberg\\'s form \\n {}'.format(sim_B))\n",
    "print('\\n')\n",
    "print('A matrix with eigenvalues on a diagonal \\n {}'.format(finall_B))\n",
    "print('\\n')\n",
    "print('The QR factorization of the initial matrix')\n",
    "print('R: {}'.format(R))\n",
    "print('Q: {}'.format(Q))\n",
    "print('The QR factorization of the initial matrix with library')\n",
    "print('R: {}'.format(np.linalg.qr(sim_B)[1]))\n",
    "print('Q: {}'.format(np.linalg.qr(sim_B)[0]))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
